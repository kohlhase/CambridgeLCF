.NH
Internal Representation of Types
.LP
Conventions: The notation [\fIty\fR] denotes the internal representation of \fIty\fR.
The content within <> is optional.
.LP
.NH 2
Type Variables
.LP
[\fItyvar\fR] \(-> (\ftyvar\fR) - explicit type variable ('a, 'b ...)
.LP 
.in 0.5i 
(%MLINK) - implicit type variable (generated by type checker) 
.in -0.5i 
.LP 
.NH Function Types 
.LP 
[\fIty1 \(-> ty2\fR] \(-> (mk-funtyp [\fIty1\fR] [\fIty2\fR])
.LP
.NH
Structure Types
.LP
[<(\fIty1,...,tyn)\fR> tycon] \(-> (\fBus \fR<[\fIty1\fR] ... [\fItyn\fR]>)
.br
where \fBus\fR is a unique lisp symbol generated at compile-time.
.LP
[{lab1:\fIty1\fR,...,labn:\fItyn\fR}] \(-> (mk-recordtyp (lab1 . [\fty1\fR]) ..
(labn . [\fItyn\fR])) - alphbetic labels
.LP
[{lab1:\fIty1\fR,...,labn:\fItyn\fR}] \(-> (mk-tupletyp [\fIty1\fR] .. [\ftyn\fR]))
.LP
[\fIty1 * ... * tyn\fR] \(-> (mk-tupletyp [\fIty1\fR] .. [\ftyn\fR]))
.LP
.NH
Scalar Types
.LP
The built-in scalar types are all represented as special cases of type construction
with the type constructor itself as the unique symbol (this is alright 
since built-in types may not be redeclared ).
[\fIint\fR] \(-> (\fIint\fR)
.br
similar for \fIbool, real, string.
.LP
[\fIty list\fR] \(-> (\fIlist \fR[\fIty1\fR])
.LP
[\fIty ref\fR] \(-> (\fIref \fR[\fIty1\fR])

